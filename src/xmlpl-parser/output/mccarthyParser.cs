//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\dat\\repository\\personal\\dev\\projects\\loblang\\src\\xmlpl-parser\\mccarthy.g3 2012-03-12 10:22:01

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

using Antlr.Runtime.Debug;
using IOException = System.IO.IOException;

using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace xmlpl_parser
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class mccarthyParser : DebugAntlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "CHAR", "COMMENT", "ESC_SEQ", "EXPONENT", "FLOAT", "HEX_DIGIT", "ID", "INT", "OCTAL_ESC", "STRING", "UNICODE_ESC", "WS", "';'", "'module'"
	};
	public const int EOF=-1;
	public const int T__16=16;
	public const int T__17=17;
	public const int CHAR=4;
	public const int COMMENT=5;
	public const int ESC_SEQ=6;
	public const int EXPONENT=7;
	public const int FLOAT=8;
	public const int HEX_DIGIT=9;
	public const int ID=10;
	public const int INT=11;
	public const int OCTAL_ESC=12;
	public const int STRING=13;
	public const int UNICODE_ESC=14;
	public const int WS=15;

	public static readonly string[] ruleNames =
		new string[]
		{
			"invalidRule", "moduleDeclaration", "module"
		};

		int ruleLevel = 0;
		public virtual int RuleLevel { get { return ruleLevel; } }
		public virtual void IncRuleLevel() { ruleLevel++; }
		public virtual void DecRuleLevel() { ruleLevel--; }
		public mccarthyParser( ITokenStream input )
			: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
		{
		}
		public mccarthyParser( ITokenStream input, int port, RecognizerSharedState state )
			: base( input, state )
		{
			ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
			CreateTreeAdaptor(ref treeAdaptor);
			TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
			DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, adaptor );
			DebugListener = proxy;
			ITokenStream = new DebugITokenStream( input, proxy );
			try
			{
				proxy.Handshake();
			}
			catch ( IOException ioe )
			{
				ReportError( ioe );
			}
			ITreeAdaptor adap = new CommonTreeAdaptor();
			TreeAdaptor = adap;
			proxy.TreeAdaptor = adap;
		}

	public mccarthyParser( ITokenStream input, IDebugEventListener dbg )
		: base( input, dbg )
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		ITreeAdaptor adap = new CommonTreeAdaptor();
		TreeAdaptor = adap;


	}

	protected virtual bool EvalPredicate( bool result, string predicate )
	{
		dbg.SemanticPredicate( result, predicate );
		return result;
	}

	// Implement this function in your helper file to use a custom tree adaptor
	partial void InitializeTreeAdaptor();
	protected DebugTreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}
		set
		{
			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);


		}
	}


	public override string[] TokenNames { get { return mccarthyParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\dat\\repository\\personal\\dev\\projects\\loblang\\src\\xmlpl-parser\\mccarthy.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_module();
	partial void LeaveRule_module();

	// $ANTLR start "module"
	// C:\\dat\\repository\\personal\\dev\\projects\\loblang\\src\\xmlpl-parser\\mccarthy.g3:79:1: public module : moduleDeclaration EOF ;
	[GrammarRule("module")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> module()
	{
		EnterRule_module();
		EnterRule("module", 1);
		TraceIn("module", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken EOF2 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> moduleDeclaration1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree EOF2_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "module");
		DebugLocation(79, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// C:\\dat\\repository\\personal\\dev\\projects\\loblang\\src\\xmlpl-parser\\mccarthy.g3:80:5: ( moduleDeclaration EOF )
			DebugEnterAlt(1);
			// C:\\dat\\repository\\personal\\dev\\projects\\loblang\\src\\xmlpl-parser\\mccarthy.g3:80:9: moduleDeclaration EOF
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(80, 9);
			PushFollow(Follow._moduleDeclaration_in_module626);
			moduleDeclaration1=moduleDeclaration();
			PopFollow();

			adaptor.AddChild(root_0, moduleDeclaration1.Tree);
			DebugLocation(81, 6);
			EOF2=(CommonToken)Match(input,EOF,Follow._EOF_in_module634); 
			EOF2_tree = (CommonTree)adaptor.Create(EOF2);
			adaptor.AddChild(root_0, EOF2_tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("module", 1);
			LeaveRule("module", 1);
			LeaveRule_module();
		}
		DebugLocation(82, 4);
		} finally { DebugExitRule(GrammarFileName, "module"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "module"

	partial void EnterRule_moduleDeclaration();
	partial void LeaveRule_moduleDeclaration();

	// $ANTLR start "moduleDeclaration"
	// C:\\dat\\repository\\personal\\dev\\projects\\loblang\\src\\xmlpl-parser\\mccarthy.g3:84:1: moduleDeclaration : 'module' ID ';' ;
	[GrammarRule("moduleDeclaration")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> moduleDeclaration()
	{
		EnterRule_moduleDeclaration();
		EnterRule("moduleDeclaration", 2);
		TraceIn("moduleDeclaration", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken string_literal3 = default(CommonToken);
		CommonToken ID4 = default(CommonToken);
		CommonToken char_literal5 = default(CommonToken);

		CommonTree string_literal3_tree = default(CommonTree);
		CommonTree ID4_tree = default(CommonTree);
		CommonTree char_literal5_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "moduleDeclaration");
		DebugLocation(84, 1);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// C:\\dat\\repository\\personal\\dev\\projects\\loblang\\src\\xmlpl-parser\\mccarthy.g3:85:2: ( 'module' ID ';' )
			DebugEnterAlt(1);
			// C:\\dat\\repository\\personal\\dev\\projects\\loblang\\src\\xmlpl-parser\\mccarthy.g3:85:4: 'module' ID ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(85, 4);
			string_literal3=(CommonToken)Match(input,17,Follow._17_in_moduleDeclaration648); 
			string_literal3_tree = (CommonTree)adaptor.Create(string_literal3);
			adaptor.AddChild(root_0, string_literal3_tree);
			DebugLocation(85, 13);
			ID4=(CommonToken)Match(input,ID,Follow._ID_in_moduleDeclaration650); 
			ID4_tree = (CommonTree)adaptor.Create(ID4);
			adaptor.AddChild(root_0, ID4_tree);
			DebugLocation(85, 16);
			char_literal5=(CommonToken)Match(input,16,Follow._16_in_moduleDeclaration652); 
			char_literal5_tree = (CommonTree)adaptor.Create(char_literal5);
			adaptor.AddChild(root_0, char_literal5_tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("moduleDeclaration", 2);
			LeaveRule("moduleDeclaration", 2);
			LeaveRule_moduleDeclaration();
		}
		DebugLocation(86, 1);
		} finally { DebugExitRule(GrammarFileName, "moduleDeclaration"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "moduleDeclaration"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _moduleDeclaration_in_module626 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_module634 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _17_in_moduleDeclaration648 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ID_in_moduleDeclaration650 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _16_in_moduleDeclaration652 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace xmlpl_parser
